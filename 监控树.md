# 两种异常处理的方式
1. try-catch
2. 监控进程, 如果出错则采取一定的措施, 比如重启, 终止等

总会出现 意料之外的错误

## 如何监控
    监控策略
        子进程之间的依赖关系
            one_for_all:
                没有顺序的互相依赖, 一个子进程的存在, 影响到其他的子进程的正常工作。
            rest_for_one:
                有顺序的依赖, 某个进程影响所有在其后面启动的进程, 而不影响在其前面启动的进程
            毫无依赖关系
                one_for_one:
                    静态进程, 手动管理
                simple_one_for_one:动态进程
                    监控树启动时 不启动任何子进程, 后期动态的使用 start_child启动进程
                    手动启动和终止, 不能使用 restart_child, delete_child(自动执行)
                    关闭监督者时
                        子进程的终止过程是并发且顺序不确定的
                        而其他方式 按照子进程的启动顺序的相反顺序, 一个堆栈的结构
                    对于子进程规格的管理
                        simple_one_for_one 使用 dict, 以 pid为键
                        其余的使用 列表, 当子进程数量庞大， 而且频繁地开始和终止的话，有效率瓶颈
                        避免一个监督者照顾过多地子进程, 可以使用轮训或是一致性hash， 随机的分配方式 进行均匀分配

    对异常子进程的重启频率
        在规定的时间内指定 重启次数, 超过这个频率, 则认为错误无法得到修复, 监督者进程需要退出, 避免循环的重启子进程。

## 子进程的描述
    id 独一无二的描述子进程的标识符
    start 启动函数， 子进程的启动入口
    restart 重启条件。 正常退出或是异常退出重启， 或是永久重启。
    shutdownTime  子进程终止的清理时间。 从监督者发出exit信号到子进程terminate回调函数返回之间允许的最长时间。
